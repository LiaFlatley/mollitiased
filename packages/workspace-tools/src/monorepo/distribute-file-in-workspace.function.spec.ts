import { mockLogger } from '@alexaegis/logging/mocks';
import { join, sep } from 'node:path/posix';
import { afterEach, describe, expect, it, vi } from 'vitest';
import { mockProjectRoot } from '../../__mocks__/fs.js';
import { cpMock, readFileMock, rmMock, symlinkMock } from '../../__mocks__/node:fs/promises.js';
import type { PackageJson } from '../index.js';
import {
	distributeFileInWorkspace,
	DISTRIBUTION_MARK,
} from './distribute-file-in-workspace.function.js';

vi.mock('globby');
vi.mock('fs');
vi.mock('node:fs/promises');
vi.mock('@alexaegis/fs', async () => {
	const mockReadJson = vi.fn<[string | undefined], Promise<unknown>>(async (_path) => {
		// For some reason the file cannot be read even though it exists
		return {
			workspaces: ['packages/*'],
		} as PackageJson;
	});

	const mockReadYaml = vi.fn<[string | undefined], Promise<unknown>>(async (_path) => {
		return undefined;
	});

	return {
		readJson: mockReadJson,
		readYaml: mockReadYaml,
		normalizeCwdOption: await vi
			.importActual<typeof import('@alexaegis/fs')>('@alexaegis/fs')
			.then((mod) => mod.normalizeCwdOption),
	};
});

describe('distributeFile', () => {
	afterEach(() => {
		vi.clearAllMocks();
	});

	it('sould expose DISTRIBUTION_MARK', () => {
		expect(DISTRIBUTION_MARK).toBeTruthy();
	});

	describe('copy', () => {
		it('should copy to all folders when not dry', async () => {
			const filename = '/foo/bar/packages/rcfile';
			await distributeFileInWorkspace(filename, {
				cwd: join(mockProjectRoot, 'packages'),
			});

			expect(cpMock).toHaveBeenCalledWith(filename, '/foo/bar/packages/zod/rcfile');
			expect(symlinkMock).not.toHaveBeenCalled();
			expect(rmMock).not.toHaveBeenCalled();
		});

		it('should not copy to any folders when dry', async () => {
			const filename = '/foo/bar/packages/rcfile';
			await distributeFileInWorkspace(filename, {
				cwd: join(mockProjectRoot, 'packages'),
				dry: true,
			});

			expect(cpMock).not.toHaveBeenCalledWith();
			expect(symlinkMock).not.toHaveBeenCalled();
			expect(rmMock).not.toHaveBeenCalled();
		});

		it('should not copy even if there is a file already there that is not autogenerated', async () => {
			const filename = '/foo/bar/packages/rcfile';
			readFileMock.mockImplementation(async (path) => {
				if (path.toString().endsWith('zed/rcfile')) {
					return 'hello custom world!';
				} else {
					return undefined;
				}
			});

			await distributeFileInWorkspace(filename, {
				cwd: join(mockProjectRoot, 'packages'),
				skipWorkspaceRoot: true,
			});

			expect(cpMock).toHaveBeenCalledWith(filename, '/foo/bar/packages/zod/rcfile');
			expect(cpMock).not.toHaveBeenCalledWith(filename, '/foo/bar/packages/zed/rcfile');

			expect(cpMock).toHaveBeenCalledTimes(1);
			expect(symlinkMock).not.toHaveBeenCalled();
			expect(rmMock).not.toHaveBeenCalled();
		});

		it('should copy even if there is a file already there but it is autogenerated', async () => {
			const filename = '/foo/bar/packages/rcfile';
			readFileMock.mockImplementation(async (path) => {
				if (path.toString().endsWith('zed/rcfile')) {
					return `${DISTRIBUTION_MARK}\nhello auto world!`;
				} else {
					return undefined;
				}
			});

			await distributeFileInWorkspace(filename, {
				cwd: join(mockProjectRoot, 'packages'),
				skipWorkspaceRoot: true,
			});

			expect(cpMock).toHaveBeenCalledWith(filename, '/foo/bar/packages/zod/rcfile');
			expect(cpMock).toHaveBeenCalledWith(filename, '/foo/bar/packages/zed/rcfile');

			expect(cpMock).toHaveBeenCalledTimes(2);
			expect(symlinkMock).not.toHaveBeenCalled();
			expect(rmMock).not.toHaveBeenCalled();
		});

		it('should log an error if it fails and there is a logger', async () => {
			cpMock.mockRejectedValueOnce('ERROR');

			const filename = '/foo/bar/packages/rcfile';

			await distributeFileInWorkspace(filename, {
				cwd: join(mockProjectRoot, 'packages'),
				logger: mockLogger,
			});

			expect(mockLogger.error).toHaveBeenCalled();
			expect(cpMock).not.toHaveBeenCalledWith();
			expect(symlinkMock).not.toHaveBeenCalled();
			expect(rmMock).not.toHaveBeenCalled();
		});
	});

	describe('force', () => {
		it('should remove existing files when force is used and is not a dry run', async () => {
			const filename = 'rcfile';
			await distributeFileInWorkspace(filename, {
				cwd: join(mockProjectRoot, 'packages'),
				force: true,
			});
			expect(rmMock).toHaveBeenCalled();
		});

		it('should not remove existing files even when force is used but it is a dry run', async () => {
			const filename = 'rcfile';
			await distributeFileInWorkspace(filename, {
				cwd: join(mockProjectRoot, 'packages'),
				force: true,
				dry: true,
			});

			expect(rmMock).not.toHaveBeenCalled();
		});
	});

	describe('symlinking', () => {
		it('should symlink to all folders', async () => {
			const filename = 'rcfile';
			await distributeFileInWorkspace(filename, {
				cwd: join(mockProjectRoot, 'packages'),
				symlinkInsteadOfCopy: true,
			});

			expect(symlinkMock).toHaveBeenCalledWith(
				`packages${sep}${filename}`,
				join(mockProjectRoot, filename)
			);
			expect(symlinkMock).toHaveBeenCalledTimes(1);
			expect(cpMock).not.toHaveBeenCalled();
			expect(rmMock).not.toHaveBeenCalled();
		});

		it('should not symlink to any folders when dry', async () => {
			const filename = 'rcfile';
			await distributeFileInWorkspace(filename, {
				cwd: join(mockProjectRoot, 'packages'),
				symlinkInsteadOfCopy: true,
				dry: true,
			});

			expect(symlinkMock).not.toHaveBeenCalled();
			expect(cpMock).not.toHaveBeenCalled();
			expect(rmMock).not.toHaveBeenCalled();
		});

		it('should refuse to link something thats nonexistent', async () => {
			const filename = 'nonexistent';
			await distributeFileInWorkspace(filename, {
				cwd: join(mockProjectRoot, 'packages'),
				symlinkInsteadOfCopy: true,
			});

			expect(symlinkMock).toHaveBeenCalledTimes(0);
			expect(cpMock).not.toHaveBeenCalled();
			expect(rmMock).not.toHaveBeenCalled();
		});

		it('should refuse to link something thats not a file', async () => {
			const filename = 'nonfile';
			await distributeFileInWorkspace(filename, {
				dependencyCriteria: ['@dep'],
				cwd: join(mockProjectRoot, 'packages'),
				symlinkInsteadOfCopy: true,
			});

			expect(symlinkMock).toHaveBeenCalledTimes(0);
			expect(cpMock).not.toHaveBeenCalled();
			expect(rmMock).not.toHaveBeenCalled();
		});

		it('should log an error if it fails and there is a logger', async () => {
			symlinkMock.mockRejectedValueOnce('ERROR');

			const filename = '/foo/bar/packages/rcfile';

			await distributeFileInWorkspace(filename, {
				cwd: join(mockProjectRoot, 'packages'),
				logger: mockLogger,
				symlinkInsteadOfCopy: true,
			});

			expect(mockLogger.error).toHaveBeenCalled();
			expect(cpMock).not.toHaveBeenCalledWith();
			expect(symlinkMock).toHaveBeenCalled();
			expect(rmMock).not.toHaveBeenCalled();
		});
	});
});
